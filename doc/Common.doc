/*!
\page DataFormats_Common Package DataFormats/Common
<center>
<small>
<a href=http://cmsdoc.cern.ch/swdev/viewcvs/viewcvs.cgi/CMSSW/DataFormats/Common/?cvsroot=CMSSW>CVS head for this package</a> - 
<a href=http://cmsdoc.cern.ch/swdev/viewcvs/viewcvs.cgi/CMSSW/DataFormats/Common/.admin/developers?rev=HEAD&cvsroot=CMSSW&content-type=text/vnd.viewcvs-markup>Administrative privileges</a>
</small>
</center>

\section desc Description
Commonly used persistent containers, references and other EDM related classes.

\subsection interface Public interface
\subsubsection I Common containers
- edm::DetSet:

- edm::ExtCollection <b>&lt;C, Ext&gt;</b>: a collection providing 
  internally as instance of a collection of type 
  <tt><b>C</b></tt> plus an intsance of the type <tt><b>Ext</b></tt> 
  specified as template parameter. The class provides the same interface of 
  <tt>std::vector&lt;C&gt;</tt> plus the methods:
\htmlonly
<pre>
  Ext & ext() { return ext_; }
  const Ext & ext() const { return ext_; }
</pre>
\endhtmlonly
that allow to access, and possibly modify, the instance <tt><b>ext_</b></tt> of the 
type <tt><b>Ext</b></tt>.

- edm::IDVectorMap:

- edm::OwnVector <b>&lt;T, P = edm::ClonePolicy&lt;T&gt; &gt;</b>: container 
  with interface very similar to <tt>std::vector&lt;T&gt;</tt>, but 
  capable of storing polymorphic objects that are owned by the 
  container to avoid memory leak. Has functionalities similar to 
  <tt>boost::ptr_vector&lt;T&gt;</tt>, but also provides EDM persistent 
  capabilities. 
  <br><br>The first template argument <tt><b>T</b></tt> is the common base class of
  polymorphic objects to be stored; the second parameter <tt><b>P</b></TT> specifies
  the <a href="#IV">policy</a> required to allocate clones of the stored object. By default, it
  is equal to the type <b>edm::ClonePolicy&lt;T&gt;</b>, which assumes that the 
  type <tt>T</tt> is equipped with a virtual method <tt><b>clone()</b></tt> that returns a cloned
  instance of the actual concrete object. Other user-provided policy implementations are possible.
  <br><br>Due to the polymorphic nature of contained objects, the STL <tt><b>std::sort</b></tt>
  functions do not work with edm::OwnVector. For this reason, functions to sort
  the collection are provided as member functions.

- edm::RangeMap <b>&lt;ID, C, P&gt;</b>: generic container of objects
  organized in a collection of type <tt><b>C</b></tt> and sorted 
  according to an identified of type <tt><b>ID</b></tt>. It is
  possible to iterate over contained object, iterate over identifiers,
  access only objects with a specified identifier, or whose identifier
  match a specified criterion. The collection is sorted before being
  inserted in the Event. The <a href="#IV">policy</a> to be used
  to produce copies/clones of the objects during insertion and final
  sorting phases can be specified as template parameter <tt><b>P</b></tt>.

- edm::SortedCollection:

\subsubsection II Persistent references
- edm::Ref: 
- edm::RefVector:
- edm::RefProd:
- edm::RefVectorIterator:
- edm::RefBase:
- edm::RefVectorBase:
- edm::RefCore:
- edm::RefItem:

- edm::Associated <b>&lt;C, T&gt;</b>: helper class to be used with an 
  edm::ExtCollection <b>&lt;C, Ext&gt;</b>, whose <tt><b>Ext</b></tt> parametric 
  type contains references (edm::RefProd &lt;T&gt;) to other "<i>associated</i>"
  collections. The functionality is better understood with the following example:
\htmlonly
<ol>
<li>We have two classes of objects, say <tt><b>AAA</b></tt> and <tt><b>BBB</b></tt> whose 
collection are to be stored in the event as:
<pre>
  std::vector&lt;AAA&gt;;
  std::vector&lt;BBB&gt;;
</pre>
<li>The two collections have the same number of events, and we would like
to define a one-to-one mapping of the objects inside the collection. 
In particular, we would like to have the collection of <tt><b>BBB</b></tt>
to hold an associaction to objects in <tt><b>AAA</b></tt>.

<li>The association is achieved defining an auxiliary new class holding a reference to 
the collection <tt><b>std::vector&lt;AAA&gt;</b></tt> 
(<tt><b>edm::RefProd&lt;std::vector&lt;AAA&gt; &gt;</b></tt>):
<pre>
  typedef std::vector&lt;AAA&gt; AAACollection;

  class BBBRefProds {
    const edm::RefProd&lt;AAACollection&gt; & aaa() const 
    { return ref_; }
    void setAaa( const edm::RefProd&lt;AAACollection&gt; ref ) 
    { ref_ = ref; }
  private:
    edm::RefProd&lt;AAACollection&gt; ref_;
  };
</pre>

<li>The collection of <tt><b>BBB</b></tt> will be now, instead of 
<tt><b>std::vector&lt;BBB&gt;</b></tt>, the following:
<pre>
  typedef edm::ExtCollection&lt;std::vector&lt;BBB&gt;, BBBRefProds&gt; BBBCollection;
</pre>

The association will be stored as a single reference, as specified by 
<tt><b>BBBRefProds</b></tt>, but
logically, relying on the object ordering inside the collection, will implement a one-to-one
mapping as in the following figure:<br><br>
<center><img src="http://cmsdoc.cern.ch/cms/cpt/Software/html/PhysicsTools/reco/documentation/associated.gif"></center><br>

<li>In order to access an object <tt><b>AAA</b></tt> from a reference to an 
object <tt><b>BBB</b></tt>, the following code can be used:
<pre>
  const edm::Ref&lt;BBBCollection&gt; bbbRef = getMeFromSomewehere();
  const AAA & aaa = 
    Associated&lt;AAACollection&gt;::get( bbbRef, &amp; BBBRefProds::aaa );
</pre>
Notice that the (pointer to the) method <tt><b>aaa</b></tt> has be passed to the <tt><b>get</b></tt>
function. This allows to define and use multiple references in <tt><b>BBBRefProds</b></tt>.
</ol>
\endhtmlonly

\subsubsection III EDM classes
- edm::BranchDescription:
- edm::BranchEntryDescription
- edm::BranchKey:
- edm::ConditionsID:
- edm::EDCollection:
- edm::EDProduct:
- edm::EDProductGetter:
- edm::ModuleDescription:
- edm::EventID:
- edm::ParameterSetID:
- edm::PassID:
- edm::ParameterSetID:
- edm::Provenance:
- edm::ProcessNameList:
- edm::ProductRegistry:
- edm::Timestamp:
- edm::TriggerResults:
- edm::VersionNumber:
- edm::Wrapper:

\subsubsection IV Helper classes
- edm::ClonePolicy <b>&lt;T&gt;</b>: Helper class that allocates a new
  clone of an objects of type <tt><b>T</b></tt> invoking the method
  <tt><b>clone()</b></tt> of the object.

- edm::CopyPolicy <b>&lt;T&gt;</b>: Helper class that returns
  a copy of an object of type <tt><b>T</b></tt> invoking the
  copy constructor of the object.

- edm::NewPolicy <b>&lt;T&gt;</b>: Helper class that allocates a new
  clone of an object of type <tt><b>T</b></tt> invoking the
  copy constructor of the object.

\subsection modules Modules
None.

\subsection tests Unit tests and examples
None.

\section status Status and planned development
Completed, stable.

<hr>
Last updated: @DATE@ L. Lista
*/
